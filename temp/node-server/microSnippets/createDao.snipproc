export class ${obj.nome}Dao {
  res: HwResponseResponse
  connection: Connection
  type: 'select' | 'insert' | 'update' | 'delete'
  query: string
  data: Array<any>
  validationData: ${obj.nome}I

  constructor({res, connection}: {res?: HwResponseResponse, connection: Connection}) {
    this.res = res
    this.connection = connection
  }

  select(...data: Array<keyof ${obj.nome}I>): ${obj.nome}Dao {
    this.validationData = undefined
    this.type = 'select'
    this.query = 'SELECT '
    this.data = []
    
    if(data.length === 0) this.query += '*'

    for (let index = 0; index < data.length; index++) {
      this.query += data[index]
      if(index !== data.length-1) this.query += ', '
    }

    this.query += ' FROM ${obj.nome}'

    return this
  }
  
  insert(data: ${obj.nome}I): ${obj.nome}Dao {
    data = modelUtils.processDataProperties(data, ${obj.nome}._properties)
    this.validationData = data
    this.type = 'insert'
    this.data = []

    let fields = '('
    let values = '('
    const keys = Object.keys(data)
    keys.forEach((key, index) => {
      this.data.push(data[key])
      fields += key
      values += '?'
      if(index !== keys.length-1) {
        fields += ', '
        values += ', '
      }
    })
    fields += ')'
    values += ')'

    this.query = `INSERT INTO ${obj.nome} <#noparse>${fields}</#noparse> VALUES <#noparse>${values}</#noparse>`
    
    return this
  }

  update(data: ${obj.nome}I): ${obj.nome}Dao {
    data = modelUtils.processDataProperties(data, ${obj.nome}._properties)
    this.validationData = data
    this.type = 'update'
    this.query = 'UPDATE ${obj.nome} SET '
    this.data = []
    
    const keys = Object.keys(data)
    keys.forEach((key, index) => {
      this.data.push(data[key])
      this.query += `<#noparse>${key}</#noparse> = ?`
      if(index !== keys.length-1) {
        this.query += ', '
      }
    })

    return this
  }

  delete(): ${obj.nome}Dao {
    this.validationData = undefined
    this.type = 'insert'
    this.query = 'DELETE FROM ${obj.nome}'
    this.data = []
    return this
  }

  where(data: ${obj.nome}WhereI): ${obj.nome}Dao {
    this.query += ' WHERE ('

    const keys = Object.keys(data)
    
    for (let index = 0; index < keys.length; index++) {
      this.query += `<#noparse>${keys[index]}</#noparse> <#noparse>${modelUtils.processWhereOperator(this.data, data[keys[index]])}</#noparse>`
      if(index !== keys.length-1) this.query += ' AND '
    }

    this.query += ')'

    return this
  }

  orderBy(...data: Array<keyof ${obj.nome}I>): ${obj.nome}Dao {
    let list = ''
    for (let index = 0; index < data.length; index++) {
      list += data[index]
      if(index !== data.length-1) list += ', '
    }
    this.query += ` ORDER BY <#noparse>${list}</#noparse>`
    return this
  }

  limit(quantity: number): ${obj.nome}Dao {
    this.data.push(quantity)
    this.query += ' LIMIT ?'
    return this
  }

  offset(quantity: number): ${obj.nome}Dao {
    this.data.push(quantity)
    this.query += ' OFFSET ?'
    return this
  }

  execute(): Promise<any> {
    return new Promise(async (resolve, reject) => {
      try {
        const isValid = await modelUtils.validateData(this.validationData, ${obj.nome}._properties, this.connection, this.res, '${obj.nome}')
        if(!isValid) {
          resolve(undefined)
          return
        }
        
        const preparedStatement = await this.connection.prepareStatement(this.query)
        await preparedStatement.format(this.data)
        
        const response = this.type === 'select' ? 
          await preparedStatement.executeQuery() :
          await preparedStatement.executeUpdate()

        switch (this.type) {
          case 'select':
            resolve(response.map(e => new ${obj.nome}(e)))
            break;
          case 'insert':
            resolve(await modelUtils.callIdentity(this.connection))
          default:
            resolve(response)
            break;
        }

      } catch (error) {
        reject(error)
      }
    })
  }
}